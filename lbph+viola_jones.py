# -*- coding: utf-8 -*-
"""LBPH+Viola-Jones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10AeyI0eySn1yAvyBrVJClDjSTqrhkiJN
"""

!pip -q install opencv-contrib-python-headless scikit-learn

from google.colab import files
files.upload()  # chọn kaggle.json

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!mkdir -p /content/data
!kaggle datasets download -d shivamvyasiitm/georgia-tech-data -p /content/data --unzip
!ls -la /content/data | head

import os
from pathlib import Path
import cv2
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# -----------------------------
# Config
# -----------------------------
DATASET_DIR = Path("/content/data/gt_db")  # <-- đổi đường dẫn
IMG_SIZE = (200, 200)
RANDOM_STATE = 42
TEST_SIZE = 0.2

# Viola–Jones (Haar cascade) face detector
face_cascade = cv2.CascadeClassifier(
    cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
)

def detect_crop_resize(gray: np.ndarray) -> np.ndarray | None:
    """
    Detect mặt bằng Viola–Jones, crop mặt lớn nhất, resize về IMG_SIZE.
    Trả về ảnh grayscale đã resize hoặc None nếu đọc lỗi.
    """
    if gray is None:
        return None

    # Tăng tương phản nhẹ (thường giúp Haar + LBPH ổn hơn)
    gray = cv2.equalizeHist(gray)

    faces = face_cascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(60, 60)
    )

    if len(faces) == 0:
        # Nếu không detect được, fallback: dùng toàn ảnh (resize)
        return cv2.resize(gray, IMG_SIZE, interpolation=cv2.INTER_AREA)

    # Chọn face lớn nhất
    x, y, w, h = max(faces, key=lambda b: b[2] * b[3])
    face_roi = gray[y:y+h, x:x+w]
    face_roi = cv2.resize(face_roi, IMG_SIZE, interpolation=cv2.INTER_AREA)
    return face_roi

def load_dataset(root: Path):
    """
    Kỳ vọng cấu trúc kiểu:
      root/
        s1/ *.jpg
        s2/ *.jpg
        ...
    Nhưng code vẫn chạy nếu folder tên khác (mỗi folder = 1 class).
    """
    X, y, label_names = [], [], []
    label_map = {}  # folder_name -> int_id

    exts = {".jpg", ".jpeg", ".png", ".bmp"}

    for sub in sorted([p for p in root.iterdir() if p.is_dir()]):
        folder_name = sub.name
        if folder_name not in label_map:
            label_map[folder_name] = len(label_map)
            label_names.append(folder_name)

        label_id = label_map[folder_name]

        for img_path in sorted(sub.rglob("*")):
            if img_path.suffix.lower() not in exts:
                continue

            img = cv2.imread(str(img_path))
            if img is None:
                continue

            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            face = detect_crop_resize(gray)
            if face is None:
                continue

            X.append(face)
            y.append(label_id)

    return X, np.array(y, dtype=np.int32), label_names

# -----------------------------
# Load data
# -----------------------------
X, y, label_names = load_dataset(DATASET_DIR)
if len(X) == 0:
    raise RuntimeError("Không load được ảnh nào. Kiểm tra lại DATASET_DIR.")

# -----------------------------
# Split 80/20 (stratify theo lớp)
# -----------------------------
X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=TEST_SIZE,
    random_state=RANDOM_STATE,
    stratify=y
)

# -----------------------------
# Train LBPH
# -----------------------------
# LBPH parameters theo docs OpenCV (neighbors=8, grid 8x8 khá phổ biến) :contentReference[oaicite:4]{index=4}
recognizer = cv2.face.LBPHFaceRecognizer_create(
    radius=1,
    neighbors=8,
    grid_x=8,
    grid_y=8
)

recognizer.train(X_train, y_train)

# -----------------------------
# Predict
# -----------------------------
y_pred = []
confidences = []

for face in X_test:
    pred_label, conf = recognizer.predict(face)  # conf: distance (thấp hơn = tốt hơn)
    y_pred.append(pred_label)
    confidences.append(conf)

y_pred = np.array(y_pred, dtype=np.int32)

# -----------------------------
# Evaluate 4 metrics
# -----------------------------
acc = accuracy_score(y_test, y_pred)
prec = precision_score(y_test, y_pred, average="macro", zero_division=0)
rec = recall_score(y_test, y_pred, average="macro", zero_division=0)
f1 = f1_score(y_test, y_pred, average="macro", zero_division=0)

print("=== LBPH + Viola–Jones (80/20) ===")
print(f"Classes: {len(label_names)} | Train: {len(X_train)} | Test: {len(X_test)}")
print(f"Accuracy        : {acc:.4f}")
print(f"Precision (macro): {prec:.4f}")
print(f"Recall (macro)   : {rec:.4f}")
print(f"F1-score (macro) : {f1:.4f}")
print(f"Mean confidence (distance, lower=better): {np.mean(confidences):.2f}")

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

recognizer = cv2.face.LBPHFaceRecognizer_create(
    radius=1, neighbors=8, grid_x=8, grid_y=8
)

recognizer.train(list(X_train), y_train)

y_pred = []
conf_scores = []

for face in X_test:
    pred, conf = recognizer.predict(face)  # conf càng nhỏ càng giống (không phải probability)
    y_pred.append(pred)
    conf_scores.append(conf)

y_pred = np.array(y_pred, dtype=np.int32)
conf_scores = np.array(conf_scores, dtype=np.float32)

from sklearn.metrics import accuracy_score, precision_recall_fscore_support

acc = accuracy_score(y_test, y_pred)
prec, rec, f1, _ = precision_recall_fscore_support(
    y_test, y_pred, average="macro", zero_division=0
)

print(f"Accuracy         : {acc:.4f}")
print(f"Precision (macro): {prec:.4f}")
print(f"Recall (macro)   : {rec:.4f}")
print(f"F1-score (macro) : {f1:.4f}")

import cv2, sys
print("cv2 version:", cv2.__version__)
print("has cv2.face:", hasattr(cv2, "face"))
if hasattr(cv2, "face"):
    print("face attrs contains LBPH?", any("LBPH" in x for x in dir(cv2.face)))
    # print(dir(cv2.face))  # nếu muốn xem hết

!pip -q uninstall -y opencv-python opencv-python-headless opencv-contrib-python opencv-contrib-python-headless
!pip -q list | grep opencv || true

!pip -q install opencv-contrib-python-headless==4.10.0.84

import cv2
print("cv2 version:", cv2.__version__)
print("has cv2.face:", hasattr(cv2, "face"))
print("LBPH in cv2.face:", hasattr(cv2.face, "LBPHFaceRecognizer_create") or
      (hasattr(cv2.face, "LBPHFaceRecognizer") and hasattr(cv2.face.LBPHFaceRecognizer, "create")))

# tạo recognizer (2 cách gọi tuỳ bản build)
if hasattr(cv2.face, "LBPHFaceRecognizer_create"):
    recognizer = cv2.face.LBPHFaceRecognizer_create(radius=1, neighbors=8, grid_x=8, grid_y=8)
else:
    recognizer = cv2.face.LBPHFaceRecognizer.create(radius=1, neighbors=8, grid_x=8, grid_y=8)

print("LBPH ready ✅")